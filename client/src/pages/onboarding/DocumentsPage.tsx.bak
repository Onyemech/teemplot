import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { FileText, Image as ImageIcon, Trash2, Upload, AlertCircle } from 'lucide-react';
import OnboardingLayout from '@/layouts/OnboardingLayout';
import Button from '@/components/ui/Button';
import { useOnboardingProgress } from '@/hooks/useOnboardingProgress';
import { uploadDocument } from '@/utils/onboardingApi';
import { getUser } from '@/utils/auth';
import { useToast } from '@/contexts/ToastContext';

interface UploadedFile {
  file: File;
  preview?: string;
}

interface DocumentState {
  cac: UploadedFile | null;
  proofOfAddress: UploadedFile | null;
  companyPolicies: UploadedFile | null;
}

export default function DocumentsPage() {
  const navigate = useNavigate();
  const toast = useToast();
  const { saveProgress, getAuthData } = useOnboardingProgress();
  const [documents, setDocuments] = useState<DocumentState>({
    cac: null,
    proofOfAddress: null,
    companyPolicies: null,
  });
  const [uploading, setUploading] = useState<string | null>(null);
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    // Load saved progress when component mounts
    const loadSavedProgress = async () => {
      try {
        const authData = getAuthData();
        if (!authData?.userId) return;

        const { getProgress } = useOnboardingProgress();
        const progress = await getProgress(authData.userId);
        
        if (progress?.formData) {
          const newDocuments: DocumentState = {
            cac: null,
            proofOfAddress: null,
            companyPolicies: null,
          };

          const restoreFile = (key: string, label: string) => {
            const data = progress.formData[key] || progress.formData[`${key}Url`] ? {
              url: progress.formData[`${key}Url`],
              filename: progress.formData[`${key}Name`] || label,
              uploaded: true
            } : null;

            if (data) {
              const filename = data.filename || label;
              const url = data.url || data.secure_url;
              const mockFile = new File([], filename, { type: 'application/pdf' });
              
              return {
                file: mockFile,
                preview: url
              };
            }
            return null;
          };

          newDocuments.cac = restoreFile('cacDocument', 'CAC Document');
          newDocuments.proofOfAddress = restoreFile('proofOfAddress', 'Proof of Address');
          newDocuments.companyPolicies = restoreFile('companyPolicies', 'Company Policies');

          setDocuments(newDocuments);
        }
      } catch (error) {
        console.error('Failed to load saved progress:', error);
      }
    };

    loadSavedProgress();
  }, [getAuthData]);

  const handleFileSelect = async (
    documentType: keyof DocumentState,
    event: React.ChangeEvent<HTMLInputElement>
  ) => {
    const file = event.target.files?.[0];
    if (!file) return;

    setError('');
    setUploading(documentType);

    try {
      // Validate file size
      const maxSizes = {
        cac: 2 * 1024 * 1024, 
        proofOfAddress: 3 * 1024 * 1024, 
        companyPolicies: 10 * 1024 * 1024, 
      };

      if (file.size > maxSizes[documentType]) {
        throw new Error(`File size exceeds maximum allowed (${maxSizes[documentType] / 1024 / 1024}MB)`);
      }

      // Validate file type
      const allowedTypes = {
        cac: ['application/pdf'],
        proofOfAddress: ['application/pdf', 'image/png', 'image/jpeg'],
        companyPolicies: ['application/pdf'],
      };

      if (!allowedTypes[documentType].includes(file.type)) {
        throw new Error('Invalid file type');
      }

      // Simulate upload delay
      await new Promise(resolve => setTimeout(resolve, 1000));

      setDocuments(prev => ({
        ...prev,
        [documentType]: { file }
      }));

    } catch (err: any) {
      setError(err.message || 'Failed to upload file');
      toast.error(err.message || 'Failed to upload file');
    } finally {
      setUploading(null);
    }
  };

  const handleRemoveFile = (documentType: keyof DocumentState) => {
    setDocuments(prev => ({
      ...prev,
      [documentType]: null
    }));
  };

  const handleSubmit = async () => {
    setError('');

    if (!documents.cac || !documents.proofOfAddress || !documents.companyPolicies) {
      setError('Please upload all required documents');
      toast.error('Please upload all required documents');
      return;
    }

    setLoading(true);

    try {
      const user = await getUser();
      
      if (!user || !user.companyId) {
        throw new Error('Session expired. Please log in again.');
      }
      
      const isAlreadyUploaded = (doc: UploadedFile | null) => {
        return doc?.preview && doc.preview.startsWith('http');
      };

      // Upload documents if not already uploaded
      const uploadIfNeeded = async (key: keyof DocumentState, apiType: string) => {
        if (!isAlreadyUploaded(documents[key]) && documents[key]) {
          const result = await uploadDocument(user.companyId, apiType, documents[key]!.file);
          const url = result.data.file.secure_url || result.data.file.url;
          setDocuments(prev => ({
            ...prev,
            [key]: { ...prev[key]!, preview: url }
          }));
          return url;
        }
        return documents[key]?.preview;
      };

      await uploadIfNeeded('cac', 'cac');
      await uploadIfNeeded('proofOfAddress', 'proof_of_address');
      await uploadIfNeeded('companyPolicies', 'company_policy');
      
      // Store document info in session storage
      sessionStorage.setItem('onboarding_documents', JSON.stringify({
        cac: documents.cac.file.name,
        proofOfAddress: documents.proofOfAddress.file.name,
        companyPolicies: documents.companyPolicies.file.name,
      }));

      toast.success('All documents uploaded successfully!');
      navigate('/onboarding/payment');

    } catch (err: any) {
      console.error('Failed to upload documents:', err);
      const errorMsg = err.message || 'Failed to save documents';
      setError(errorMsg);
      toast.error(errorMsg);
    } finally {
      setLoading(false);
    }
  };

  const handleBack = () => {
    navigate('/onboarding/owner-details');
  };

  const formatFileSize = (bytes: number) => {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  };

  const getFileIcon = (fileName: string) => {
    const ext = fileName.split('.').pop()?.toLowerCase();
    if (ext === 'pdf') {
      return <FileText className="w-5 h-5 text-red-500" />;
    }
    return <ImageIcon className="w-5 h-5 text-green-500" />;
  };

  const DocumentUploadSection = ({
    title,
    description,
    documentType,
    acceptedFormats,
  }: {
    title: string;
    description: string;
    documentType: keyof DocumentState;
    acceptedFormats: string;
  }) => {
    const uploadedFile = documents[documentType];
    const isUploading = uploading === documentType;

    return (
      <div className="mb-6">
        <h3 className="text-base font-semibold text-gray-900 mb-1">{title}</h3>
        <p className="text-sm text-gray-600 mb-3">{description}</p>

        {uploadedFile ? (
          <div className="flex items-center justify-between p-4 bg-gray-50 border border-gray-200 rounded-lg">
            <div className="flex items-center gap-3">
              {getFileIcon(uploadedFile.file.name)}
              <div>
                <p className="text-sm font-medium text-gray-900">{uploadedFile.file.name}</p>
                <p className="text-xs text-gray-700">{formatFileSize(uploadedFile.file.size)}</p>
              </div>
            </div>
            <button
              onClick={() => handleRemoveFile(documentType)}
              className="p-2 text-gray-400 hover:text-red-500 transition-colors"
              aria-label="Remove file"
            >
              <Trash2 className="w-4 h-4" />
            </button>
          </div>
        ) : (
          <div className="relative">
            <input
              type="file"
              id={documentType}
              accept={acceptedFormats}
              onChange={(e) => handleFileSelect(documentType, e)}
              className="hidden"
              disabled={isUploading}
            />
            <label
              htmlFor={documentType}
              className={`
                flex items-center justify-center gap-2 p-4 
                border-2 border-dashed border-gray-300 rounded-lg
                cursor-pointer hover:border-[#0F5D5D] hover:bg-teal-50
                transition-colors
                ${isUploading ? 'opacity-50 cursor-not-allowed' : ''}
              `}
            >
              {isUploading ? (
                <>
                  <div className="animate-spin w-5 h-5 border-2 border-[#0F5D5D] border-t-transparent rounded-full" />
                  <span className="text-sm text-gray-600">Uploading...</span>
                </>
              ) : (
                <>
                  <Upload className="w-5 h-5 text-gray-400" />
                  <span className="text-sm text-gray-600">Click to upload</span>
                </>
              )}
            </label>
          </div>
        )}
      </div>
    );
  };

  return (
    <OnboardingLayout 
      currentStep={3} 
      title="Legal company documents"
      description="These are required documents we need in order to verify that the business information you provided are correct"
      onBack={handleBack}
    >
      {error && (
        <div className="mb-6 p-4 bg-red-50 border border-red-200 rounded-lg text-red-600 text-sm flex items-center gap-2">
          <AlertCircle className="w-4 h-4 flex-shrink-0" />
          {error}
        </div>
      )}

      <div className="space-y-6">
        <DocumentUploadSection
          title="C.A.C document"
          description="This is used to verify the business detail you provided"
          documentType="cac"
          acceptedFormats=".pdf"
        />

        <DocumentUploadSection
          title="Proof of address"
          description="This is used to verify the business address"
          documentType="proofOfAddress"
          acceptedFormats=".pdf,.png,.jpg,.jpeg"
        />

        <DocumentUploadSection
          title="Company policies document"
          description="This is to ensure that your company adheres to standard company practices"
          documentType="companyPolicies"
          acceptedFormats=".pdf"
        />

        <Button
          type="button"
          isLoading={loading}
          onClick={handleSubmit}
          className="w-full bg-[#0F5D5D] hover:bg-[#0b4646] text-white py-3 mt-8"
          disabled={!documents.cac || !documents.proofOfAddress || !documents.companyPolicies}
        >
          Continue
        </Button>
      </div>
    </OnboardingLayout>
  );
}
