import { createClient } from '@supabase/supabase-js';
import { DatabaseFactory } from '../infrastructure/database/DatabaseFactory';
import { IDatabase } from '../infrastructure/database/IDatabase';
import { logger } from '../utils/logger';
import { randomUUID } from 'crypto';

interface GoogleUserInfo {
  id: string;
  email: string;
  verified_email: boolean;
  name: string;
  given_name: string;
  family_name: string;
  picture: string;
}

export class GoogleAuthService {
  private db: IDatabase;
  private supabase;

  constructor() {
    this.db = DatabaseFactory.getPrimaryDatabase();
    
    // Initialize Supabase client
    const supabaseUrl = process.env.SUPABASE_URL;
    const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
    
    if (!supabaseUrl || !supabaseKey) {
      throw new Error('Supabase configuration missing');
    }
    
    this.supabase = createClient(supabaseUrl, supabaseKey);
  }

  /**
   * Handle Google OAuth callback and sync with local database
   */
  async handleGoogleAuth(googleUser: GoogleUserInfo): Promise<{
    user: any;
    token: string;
    isNewUser: boolean;
    requiresOnboarding: boolean;
  }> {
    try {
      // Check if user exists in local database
      const existingUser = await this.db.findOne('users', { 
        email: googleUser.email 
      });

      if (existingUser) {
        // User exists - update Google ID if not set and return
        if (!existingUser.google_id) {
          await this.db.update(
            'users',
            { 
              google_id: googleUser.id,
              avatar_url: googleUser.picture,
              email_verified: 1,
              last_login_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            },
            { id: existingUser.id }
          );
          
          // Sync to Supabase
          await this.syncToSupabase(existingUser.email, {
            id: existingUser.id,
            first_name: existingUser.first_name,
            last_name: existingUser.last_name,
            google_id: googleUser.id,
            avatar_url: googleUser.picture,
            company_id: existingUser.company_id,
            role: existingUser.role,
          });
        } else {
          // Just update last login
          await this.db.update(
            'users',
            { 
              last_login_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            },
            { id: existingUser.id }
          );
        }

        // Check if company onboarding is complete
        const company = await this.db.findOne('companies', { id: existingUser.company_id });
        const requiresOnboarding = !company || company.onboarding_completed === 0;

        return {
          user: existingUser,
          token: '', // Will be generated by caller
          isNewUser: false,
          requiresOnboarding
        };
      }

      // New user - create temporary company first, then user
      const userId = randomUUID();
      const tempCompanyId = randomUUID(); // Create actual UUID for temp company

      // Create temporary company for onboarding
      const tempCompany = {
        id: tempCompanyId,
        name: 'Pending Onboarding',
        slug: `temp-${userId.substring(0, 8)}`,
        email: googleUser.email,
        subscription_plan: 'trial',
        subscription_status: 'pending',
        is_active: 0, // Inactive until onboarding completes
        onboarding_completed: 0,
        employee_count: 1,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      await this.db.insert('companies', tempCompany);

      const newUser = {
        id: userId,
        company_id: tempCompanyId,
        email: googleUser.email,
        password_hash: null, // No password for Google auth users
        first_name: googleUser.given_name || googleUser.name.split(' ')[0] || 'User',
        last_name: googleUser.family_name || googleUser.name.split(' ').slice(1).join(' ') || 'Account',
        google_id: googleUser.id,
        avatar_url: googleUser.picture,
        role: 'owner', 
        email_verified: 1, 
        is_active: 1,
        last_login_at: new Date().toISOString(),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      await this.db.insert('users', newUser);

      // Sync to Supabase public.users
      await this.syncToSupabase(googleUser.email, {
        id: userId,
        first_name: newUser.first_name,
        last_name: newUser.last_name,
        google_id: googleUser.id,
        avatar_url: googleUser.picture,
        company_id: tempCompanyId,
        role: 'owner',
      });

      logger.info({ userId, email: googleUser.email }, 'New Google user created and synced to Supabase');

      return {
        user: newUser,
        token: '', // Will be generated by caller
        isNewUser: true,
        requiresOnboarding: true
      };
    } catch (error) {
      logger.error({ err: error }, 'Google auth handling failed');
      throw error;
    }
  }

  /**
   * Complete onboarding for Google auth user
   */
  async completeOnboarding(userId: string, companyData: {
    companyName: string;
    industry?: string;
    companySize?: string;
    phoneNumber?: string;
    address?: string;
    timezone?: string;
  }): Promise<{ companyId: string }> {
    try {
      const user = await this.db.findOne('users', { id: userId });
      
      if (!user) {
        throw new Error('User not found');
      }

      const oldCompanyId = user.company_id;

      // Update the existing temp company with real data
      const companySlug = companyData.companyName
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-|-$/g, '');

      const companyUpdate = {
        name: companyData.companyName,
        slug: companySlug,
        email: user.email,
        phone_number: companyData.phoneNumber || null,
        address: companyData.address || null,
        industry: companyData.industry || null,
        company_size: companyData.companySize || null,
        timezone: companyData.timezone || 'UTC',
        subscription_plan: 'trial',
        subscription_status: 'active',
        trial_start_date: new Date().toISOString(),
        trial_end_date: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString(),
        is_active: 1,
        onboarding_completed: 1,
        employee_count: 1,
        updated_at: new Date().toISOString()
      };

      // Update the temp company instead of creating a new one
      await this.db.update('companies', companyUpdate, { id: oldCompanyId });

      // User already has the correct company_id, just update last modified
      await this.db.update(
        'users',
        { 
          updated_at: new Date().toISOString()
        },
        { id: userId }
      );

      // Get the updated company for syncing
      const updatedCompany = await this.db.findOne('companies', { id: oldCompanyId });

      // Sync company to Supabase public.companies
      if (updatedCompany) {
        await this.syncCompanyToSupabase(updatedCompany);
      }

      // Sync updated user to Supabase public.users
      await this.syncToSupabase(user.email, {
        id: userId,
        first_name: user.first_name,
        last_name: user.last_name,
        google_id: user.google_id,
        avatar_url: user.avatar_url,
        company_id: oldCompanyId,
        role: user.role,
        onboarding_completed: true
      });

      logger.info({ userId, companyId: oldCompanyId }, 'Google user onboarding completed and synced to Supabase');

      return { companyId: oldCompanyId };
    } catch (error) {
      logger.error({ err: error }, 'Onboarding completion failed');
      throw error;
    }
  }

  /**
   * Sync company data to Supabase public.companies table
   */
  private async syncCompanyToSupabase(company: any): Promise<void> {
    try {
      // Check if company exists in Supabase
      const { data: existingCompany, error: selectError } = await this.supabase
        .from('companies')
        .select('*')
        .eq('id', company.id)
        .single();

      const companyRecord = {
        id: company.id,
        name: company.name,
        slug: company.slug,
        email: company.email,
        phone_number: company.phone_number,
        address: company.address,
        industry: company.industry,
        company_size: company.company_size,
        timezone: company.timezone,
        subscription_plan: company.subscription_plan,
        subscription_status: company.subscription_status,
        trial_start_date: company.trial_start_date,
        trial_end_date: company.trial_end_date,
        is_active: company.is_active,
        onboarding_completed: company.onboarding_completed,
        employee_count: company.employee_count,
        created_at: company.created_at,
        updated_at: company.updated_at,
      };

      if (existingCompany) {
        // Update existing company
        const { error: updateError } = await this.supabase
          .from('companies')
          .update(companyRecord)
          .eq('id', company.id);

        if (updateError) {
          logger.error({ err: updateError }, 'Failed to update Supabase public.companies');
        } else {
          logger.info({ companyId: company.id }, 'Updated company in Supabase public.companies');
        }
      } else {
        // Insert new company
        const { error: insertError } = await this.supabase
          .from('companies')
          .insert(companyRecord);

        if (insertError) {
          logger.error({ err: insertError }, 'Failed to insert into Supabase public.companies');
        } else {
          logger.info({ companyId: company.id }, 'Inserted company into Supabase public.companies');
        }
      }
    } catch (error) {
      logger.error({ err: error }, 'Supabase company sync failed');
      // Don't throw - this is not critical
    }
  }

  /**
   * Sync user data to Supabase public.users table
   */
  private async syncToSupabase(email: string, userData: any): Promise<void> {
    try {
      // Get Supabase auth user by email
      const { data: authUsers, error: listError } = await this.supabase.auth.admin.listUsers();
      
      if (listError) {
        logger.error({ err: listError }, 'Failed to list Supabase auth users');
        return;
      }

      const supabaseAuthUser = authUsers.users.find(u => u.email === email);
      
      if (!supabaseAuthUser) {
        logger.warn({ email }, 'Supabase auth user not found for sync');
        return;
      }

      // Update auth user metadata
      await this.supabase.auth.admin.updateUserById(
        supabaseAuthUser.id,
        { user_metadata: userData }
      );

      // Sync to public.users table
      const { data: existingUser, error: selectError } = await this.supabase
        .from('users')
        .select('*')
        .eq('email', email)
        .single();

      const userRecord = {
        email: email,
        first_name: userData.first_name || userData.firstName || '',
        last_name: userData.last_name || userData.lastName || '',
        google_id: userData.google_id || '',
        avatar_url: userData.avatar_url || userData.avatarUrl || null,
        company_id: userData.company_id || userData.companyId || null,
        role: userData.role || 'owner',
        email_verified: true,
        is_active: true,
        updated_at: new Date().toISOString(),
      };

      if (existingUser) {
        // Update existing user in public.users
        const { error: updateError } = await this.supabase
          .from('users')
          .update(userRecord)
          .eq('email', email);

        if (updateError) {
          logger.error({ err: updateError }, 'Failed to update Supabase public.users');
        } else {
          logger.info({ email }, 'Updated user in Supabase public.users');
        }
      } else {
        // Insert new user into public.users
        const { error: insertError } = await this.supabase
          .from('users')
          .insert({
            id: userData.id,
            ...userRecord,
            password_hash: null, // Google auth users don't have passwords
            created_at: new Date().toISOString(),
          });

        if (insertError) {
          logger.error({ err: insertError }, 'Failed to insert into Supabase public.users');
        } else {
          logger.info({ email }, 'Inserted user into Supabase public.users');
        }
      }
    } catch (error) {
      logger.error({ err: error }, 'Supabase sync failed');
      // Don't throw - this is not critical
    }
  }

  /**
   * Get or create user from Supabase session
   */
  async getUserFromSupabaseSession(accessToken: string): Promise<GoogleUserInfo | null> {
    try {
      const { data: { user }, error } = await this.supabase.auth.getUser(accessToken);
      
      if (error || !user) {
        return null;
      }

      // Extract Google user info from Supabase user
      const googleUser: GoogleUserInfo = {
        id: user.user_metadata.provider_id || user.id,
        email: user.email!,
        verified_email: user.email_confirmed_at !== null,
        name: user.user_metadata.full_name || user.user_metadata.name || '',
        given_name: user.user_metadata.given_name || user.user_metadata.first_name || '',
        family_name: user.user_metadata.family_name || user.user_metadata.last_name || '',
        picture: user.user_metadata.avatar_url || user.user_metadata.picture || ''
      };

      return googleUser;
    } catch (error) {
      logger.error({ err: error }, 'Failed to get user from Supabase session');
      return null;
    }
  }
}

export const googleAuthService = new GoogleAuthService();
